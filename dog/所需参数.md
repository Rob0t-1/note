- 机身参数
  - 长
  - 宽
  - 高
  - 质量
  - 四个脚髋关节相对机身坐标系的位置：x、y、z
- 机身转动惯量
  1.三维建模软件求得
  2.手工计算得
  ![[pic1.png]](picture/pic1.png)

- **三次样条插值**
  规划跳跃时z轴轨迹
    ![[pic2.png]](picture/pic2.png)
  （由于在节点处相邻样条的的一阶导和二阶导都相等，能不能拿来做足端摆线？）
  > 样条插值函数求解过程c代码
    下面是一个使用 C 语言实现三次样条插值的示例代码。该代码将根据给定的控制点计算样条插值的系数，并提供一个函数用于在给定的 x 值上进行插值。
    ```
    #include <stdio.h>
    #include <stdlib.h>

    typedef struct {
        double a, b, c, d; // 三次样条的系数
    } SplineSegment;

    void cubicSpline(int n, double x[], double y[], SplineSegment segments[]) {
        double *h = (double *)malloc((n - 1) * sizeof(double));
        double *alpha = (double *)malloc((n - 1) * sizeof(double));
        double *l = (double *)malloc((n + 1) * sizeof(double));
        double *mu = (double *)malloc((n - 1) * sizeof(double));
        double *z = (double *)malloc((n + 1) * sizeof(double));
        double *c = (double *)malloc((n + 1) * sizeof(double));
        double *b = (double *)malloc((n - 1) * sizeof(double));
        double *d = (double *)malloc((n - 1) * sizeof(double));

        // 计算 h 和 alpha
        for (int i = 0; i < n - 1; i++) {
            h[i] = x[i + 1] - x[i];
        }
        for (int i = 1; i < n - 1; i++) {
            alpha[i] = (3.0 / h[i]) * (y[i + 1] - y[i]) - (3.0 / h[i - 1]) * (y[i] - y[i - 1]);
        }

        // 设置边界条件
        l[0] = 1.0;
        mu[0] = z[0] = 0.0;

        // 计算 l, mu, z
        for (int i = 1; i < n - 1; i++) {
            l[i] = 2.0 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
            mu[i] = h[i] / l[i];
            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
        }
        l[n - 1] = 1.0;
        z[n - 1] = 0.0;

        // 计算 c, b, d
        for (int j = n - 2; j >= 0; j--) {
            c[j] = z[j] - mu[j] * c[j + 1];
            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2.0 * c[j]) / 3.0;
            d[j] = (c[j + 1] - c[j]) / h[j];
        }

        // 将系数存储到 segments 中
        for (int i = 0; i < n - 1; i++) {
            segments[i].a = y[i];
            segments[i].b = b[i];
            segments[i].c = c[i];
            segments[i].d = d[i];
        }

        // 释放内存
        free(h);
        free(alpha);
        free(l);
        free(mu);
        free(z);
        free(c);
        free(b);
        free(d);
    }

    // 插值函数
    double interpolate(SplineSegment segments[], int n, double x[], double x_val) {
        int i;
        for (i = 0; i < n - 1; i++) {
            if (x_val <= x[i + 1]) {
                break;
            }
        }
        double dx = x_val - x[i];
        return segments[i].a + segments[i].b * dx + segments[i].c * dx * dx + segments[i].d * dx * dx * dx;
    }

    int main() {
        // 示例数据
        double x[] = {0, 1, 2, 3, 4};
        double y[] = {0, 2, 1, 3, 0};
        int n = sizeof(x) / sizeof(x[0]);

        // 创建样条段数组
        SplineSegment *segments = (SplineSegment *)malloc((n - 1) * sizeof(SplineSegment));

        // 计算样条插值
        cubicSpline(n, x, y, segments);

        // 输出样条系数
        for (int i = 0; i < n - 1; i++) {
            printf("Segment %d: a = %.2f, b = %.2f, c = %.2f, d = %.2f\n", 
                   i, segments[i].a, segments[i].b, segments[i].c, segments[i].d);
        }

        // 测试插值
        double test_x = 2.5;
        double interpolated_value = interpolate(segments, n, x, test_x);
        printf("Interpolated value at x = %.2f: %.2f\n", test_x, interpolated_value);

        // 释放内存
        free(segments);
        return 0;
    }
    ```
    左摇杆2345 右摇杆6789
    左上12
    电机使能11
    左环15 右环16
    包头0 1
    按键模式 10
    状态 13
    跳的动作 14

    增加模式（遥控器那边还不懂）
    freertos_demo.c中

### 需要调整的参数：
#### 跳跃：
-  测试模式开启（测轨迹规划）
    jump.h
- kpkd：
    jump.c
- 轨迹：
    jump_data.c
    jump_data.h
#### 其它
    VMC_Posture.c
#### 匍匐前进
    现在的kpkd是进到VMC_CreepMoving函数里面由普通行走的kpkd乘一个系数得到的
    改x、y轴偏移量在cycloid.c里的const float CREEP_OFFSET_X和const float CREEP_OFFSET_Y
VMC_CreepMoving函数里赋值给
